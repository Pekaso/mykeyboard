   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.unselect_rows,"ax",@progbits
  12               	unselect_rows:
  13               	.LFB18:
  14               		.file 1 "matrix.c"
   1:matrix.c      **** /*
   2:matrix.c      **** Copyright 2012 Jun Wako <wakojun@gmail.com>
   3:matrix.c      **** 
   4:matrix.c      **** This program is free software: you can redistribute it and/or modify
   5:matrix.c      **** it under the terms of the GNU General Public License as published by
   6:matrix.c      **** the Free Software Foundation, either version 2 of the License, or
   7:matrix.c      **** (at your option) any later version.
   8:matrix.c      **** 
   9:matrix.c      **** This program is distributed in the hope that it will be useful,
  10:matrix.c      **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:matrix.c      **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:matrix.c      **** GNU General Public License for more details.
  13:matrix.c      **** 
  14:matrix.c      **** You should have received a copy of the GNU General Public License
  15:matrix.c      **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:matrix.c      **** */
  17:matrix.c      **** 
  18:matrix.c      **** /*
  19:matrix.c      ****  * scan matrix
  20:matrix.c      ****  */
  21:matrix.c      **** #include <stdint.h>
  22:matrix.c      **** #include <stdbool.h>
  23:matrix.c      **** #include <avr/io.h>
  24:matrix.c      **** #include <util/delay.h>
  25:matrix.c      **** #include "print.h"
  26:matrix.c      **** #include "debug.h"
  27:matrix.c      **** #include "util.h"
  28:matrix.c      **** #include "matrix.h"
  29:matrix.c      **** 
  30:matrix.c      **** 
  31:matrix.c      **** #ifndef DEBOUNCE
  32:matrix.c      **** #define DEBOUNCE	5
  33:matrix.c      **** #endif
  34:matrix.c      **** static uint8_t debouncing = DEBOUNCE;
  35:matrix.c      **** 
  36:matrix.c      **** /* matrix state(1:on, 0:off) */
  37:matrix.c      **** static matrix_row_t matrix[MATRIX_ROWS];
  38:matrix.c      **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  39:matrix.c      **** 
  40:matrix.c      **** static matrix_row_t read_cols(void);
  41:matrix.c      **** static void init_cols(void);
  42:matrix.c      **** static void unselect_rows(void);
  43:matrix.c      **** static void select_row(uint8_t row);
  44:matrix.c      **** 
  45:matrix.c      **** 
  46:matrix.c      **** inline
  47:matrix.c      **** uint8_t matrix_rows(void)
  48:matrix.c      **** {
  49:matrix.c      ****     return MATRIX_ROWS;
  50:matrix.c      **** }
  51:matrix.c      **** 
  52:matrix.c      **** inline
  53:matrix.c      **** uint8_t matrix_cols(void)
  54:matrix.c      **** {
  55:matrix.c      ****     return MATRIX_COLS;
  56:matrix.c      **** }
  57:matrix.c      **** 
  58:matrix.c      **** void matrix_init(void)
  59:matrix.c      **** {
  60:matrix.c      ****     // initialize row and col
  61:matrix.c      ****     unselect_rows();
  62:matrix.c      ****     init_cols();
  63:matrix.c      **** 
  64:matrix.c      ****     // initialize matrix state: all keys off
  65:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
  66:matrix.c      ****         matrix[i] = 0;
  67:matrix.c      ****         matrix_debouncing[i] = 0;
  68:matrix.c      ****     }
  69:matrix.c      **** }
  70:matrix.c      **** 
  71:matrix.c      **** uint8_t matrix_scan(void)
  72:matrix.c      **** {
  73:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
  74:matrix.c      ****         select_row(i);
  75:matrix.c      ****         _delay_us(30);  // without this wait read unstable value.
  76:matrix.c      ****         matrix_row_t cols = read_cols();
  77:matrix.c      ****         if (matrix_debouncing[i] != cols) {
  78:matrix.c      ****             matrix_debouncing[i] = cols;
  79:matrix.c      ****             if (debouncing) {
  80:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
  81:matrix.c      ****             }
  82:matrix.c      ****             debouncing = DEBOUNCE;
  83:matrix.c      ****         }
  84:matrix.c      ****         unselect_rows();
  85:matrix.c      ****     }
  86:matrix.c      **** 
  87:matrix.c      ****     if (debouncing) {
  88:matrix.c      ****         if (--debouncing) {
  89:matrix.c      ****             _delay_ms(1);
  90:matrix.c      ****         } else {
  91:matrix.c      ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
  92:matrix.c      ****                 matrix[i] = matrix_debouncing[i];
  93:matrix.c      ****             }
  94:matrix.c      ****         }
  95:matrix.c      ****     }
  96:matrix.c      **** 
  97:matrix.c      ****     return 1;
  98:matrix.c      **** }
  99:matrix.c      **** 
 100:matrix.c      **** bool matrix_is_modified(void)
 101:matrix.c      **** {
 102:matrix.c      ****     if (debouncing) return false;
 103:matrix.c      ****     return true;
 104:matrix.c      **** }
 105:matrix.c      **** 
 106:matrix.c      **** inline
 107:matrix.c      **** bool matrix_is_on(uint8_t row, uint8_t col)
 108:matrix.c      **** {
 109:matrix.c      ****     return (matrix[row] & ((matrix_row_t)1<<col));
 110:matrix.c      **** }
 111:matrix.c      **** 
 112:matrix.c      **** inline
 113:matrix.c      **** matrix_row_t matrix_get_row(uint8_t row)
 114:matrix.c      **** {
 115:matrix.c      ****     return matrix[row];
 116:matrix.c      **** }
 117:matrix.c      **** 
 118:matrix.c      **** void matrix_print(void)
 119:matrix.c      **** {
 120:matrix.c      ****     print("\nr/c 0123456789ABCDEF\n");
 121:matrix.c      ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 122:matrix.c      ****         phex(row); print(": ");
 123:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 124:matrix.c      ****         print("\n");
 125:matrix.c      ****     }
 126:matrix.c      **** }
 127:matrix.c      **** 
 128:matrix.c      **** uint8_t matrix_key_count(void)
 129:matrix.c      **** {
 130:matrix.c      ****     uint8_t count = 0;
 131:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 132:matrix.c      ****         count += bitpop16(matrix[i]);
 133:matrix.c      ****     }
 134:matrix.c      ****     return count;
 135:matrix.c      **** }
 136:matrix.c      **** 
 137:matrix.c      **** /* Column pin configuration
 138:matrix.c      ****  * col: 0   1   2   3   4   5   6   7   8   9   10  11  12  13  14
 139:matrix.c      ****  * pin: B6  B5  B4  D7  D6  C7  C6  D3  D2  D1  D0  B7  B3  B2  B1
 140:matrix.c      ****  */
 141:matrix.c      **** static void  init_cols(void)
 142:matrix.c      **** {
 143:matrix.c      ****     // Input with pull-up(DDR:0, PORT:1)
 144:matrix.c      ****   DDRB  &= ~(1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<3 | 1<<2 | 1<<1);
 145:matrix.c      ****   PORTB |= (1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<3 | 1<<2 | 1<<1);
 146:matrix.c      ****   DDRD  &= ~(1<<7 | 1<<6 | 1<<3 | 1<<2 | 1<<1 | 1<<0);
 147:matrix.c      ****   PORTD |= (1<<7 | 1<<6 | 1<<3 | 1<<2 | 1<<1 | 1<<0);
 148:matrix.c      ****   DDRC  &= ~(1<<7 | 1<<6);
 149:matrix.c      ****   PORTC |= (1<<7 | 1<<6);
 150:matrix.c      **** }
 151:matrix.c      **** 
 152:matrix.c      **** static matrix_row_t read_cols(void)
 153:matrix.c      **** {
 154:matrix.c      ****   return (PINB&(1<<6) ? 0 : (1<<0)) |
 155:matrix.c      ****          (PINB&(1<<5) ? 0 : (1<<1)) |
 156:matrix.c      ****          (PINB&(1<<4) ? 0 : (1<<2)) |
 157:matrix.c      ****          (PIND&(1<<7) ? 0 : (1<<3)) |
 158:matrix.c      ****          (PIND&(1<<6) ? 0 : (1<<4)) |
 159:matrix.c      ****          (PINC&(1<<7) ? 0 : (1<<5)) |
 160:matrix.c      ****          (PINC&(1<<6) ? 0 : (1<<6)) |
 161:matrix.c      ****          (PIND&(1<<3) ? 0 : (1<<7)) |
 162:matrix.c      ****          (PIND&(1<<2) ? 0 : (1<<8)) |
 163:matrix.c      ****          (PIND&(1<<1) ? 0 : (1<<9)) |
 164:matrix.c      ****          (PIND&(1<<0) ? 0 : (1<<10)) |
 165:matrix.c      ****          (PINB&(1<<7) ? 0 : (1<<11)) |
 166:matrix.c      ****          (PINB&(1<<3) ? 0 : (1<<12)) |
 167:matrix.c      ****          (PINB&(1<<2) ? 0 : (1<<13)) |
 168:matrix.c      ****          (PINB&(1<<1) ? 0 : (1<<14));
 169:matrix.c      **** }
 170:matrix.c      **** 
 171:matrix.c      **** /* Row pin configuration
 172:matrix.c      ****  * row: 0   1   2   3   4   5
 173:matrix.c      ****  * pin: F0  F1  F4  F5  F6  F7
 174:matrix.c      ****  */
 175:matrix.c      **** static void unselect_rows(void)
 176:matrix.c      **** {
  15               		.loc 1 176 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
 177:matrix.c      ****     // Hi-Z(DDR:0, PORT:0) to unselect
 178:matrix.c      ****     DDRF  &= ~0b11110011;
  21               		.loc 1 178 0
  22 0000 80B3      		in r24,0x10
  23 0002 8C70      		andi r24,lo8(12)
  24 0004 80BB      		out 0x10,r24
 179:matrix.c      ****     PORTF &= ~0b11110011;
  25               		.loc 1 179 0
  26 0006 81B3      		in r24,0x11
  27 0008 8C70      		andi r24,lo8(12)
  28 000a 81BB      		out 0x11,r24
  29 000c 0895      		ret
  30               		.cfi_endproc
  31               	.LFE18:
  33               		.section	.text.matrix_rows,"ax",@progbits
  34               	.global	matrix_rows
  36               	matrix_rows:
  37               	.LFB7:
  48:matrix.c      ****     return MATRIX_ROWS;
  38               		.loc 1 48 0
  39               		.cfi_startproc
  40               	/* prologue: function */
  41               	/* frame size = 0 */
  42               	/* stack size = 0 */
  43               	.L__stack_usage = 0
  50:matrix.c      **** 
  44               		.loc 1 50 0
  45 0000 86E0      		ldi r24,lo8(6)
  46 0002 0895      		ret
  47               		.cfi_endproc
  48               	.LFE7:
  50               		.section	.text.matrix_cols,"ax",@progbits
  51               	.global	matrix_cols
  53               	matrix_cols:
  54               	.LFB8:
  54:matrix.c      ****     return MATRIX_COLS;
  55               		.loc 1 54 0
  56               		.cfi_startproc
  57               	/* prologue: function */
  58               	/* frame size = 0 */
  59               	/* stack size = 0 */
  60               	.L__stack_usage = 0
  56:matrix.c      **** 
  61               		.loc 1 56 0
  62 0000 8FE0      		ldi r24,lo8(15)
  63 0002 0895      		ret
  64               		.cfi_endproc
  65               	.LFE8:
  67               		.section	.text.matrix_init,"ax",@progbits
  68               	.global	matrix_init
  70               	matrix_init:
  71               	.LFB9:
  59:matrix.c      ****     // initialize row and col
  72               		.loc 1 59 0
  73               		.cfi_startproc
  74               	/* prologue: function */
  75               	/* frame size = 0 */
  76               	/* stack size = 0 */
  77               	.L__stack_usage = 0
  61:matrix.c      ****     init_cols();
  78               		.loc 1 61 0
  79 0000 0E94 0000 		call unselect_rows
  80               	.LVL0:
  81               	.LBB23:
  82               	.LBB24:
 144:matrix.c      ****   PORTB |= (1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<3 | 1<<2 | 1<<1);
  83               		.loc 1 144 0
  84 0004 84B1      		in r24,0x4
  85 0006 8170      		andi r24,lo8(1)
  86 0008 84B9      		out 0x4,r24
 145:matrix.c      ****   DDRD  &= ~(1<<7 | 1<<6 | 1<<3 | 1<<2 | 1<<1 | 1<<0);
  87               		.loc 1 145 0
  88 000a 85B1      		in r24,0x5
  89 000c 8E6F      		ori r24,lo8(-2)
  90 000e 85B9      		out 0x5,r24
 146:matrix.c      ****   PORTD |= (1<<7 | 1<<6 | 1<<3 | 1<<2 | 1<<1 | 1<<0);
  91               		.loc 1 146 0
  92 0010 8AB1      		in r24,0xa
  93 0012 8073      		andi r24,lo8(48)
  94 0014 8AB9      		out 0xa,r24
 147:matrix.c      ****   DDRC  &= ~(1<<7 | 1<<6);
  95               		.loc 1 147 0
  96 0016 8BB1      		in r24,0xb
  97 0018 8F6C      		ori r24,lo8(-49)
  98 001a 8BB9      		out 0xb,r24
 148:matrix.c      ****   PORTC |= (1<<7 | 1<<6);
  99               		.loc 1 148 0
 100 001c 87B1      		in r24,0x7
 101 001e 8F73      		andi r24,lo8(63)
 102 0020 87B9      		out 0x7,r24
 149:matrix.c      **** }
 103               		.loc 1 149 0
 104 0022 88B1      		in r24,0x8
 105 0024 806C      		ori r24,lo8(-64)
 106 0026 88B9      		out 0x8,r24
 107               	.LVL1:
 108 0028 E0E0      		ldi r30,lo8(matrix)
 109 002a F0E0      		ldi r31,hi8(matrix)
 110 002c A0E0      		ldi r26,lo8(matrix_debouncing)
 111 002e B0E0      		ldi r27,hi8(matrix_debouncing)
 112               	.LVL2:
 113               	.L5:
 114               	.LBE24:
 115               	.LBE23:
 116               	.LBB25:
  66:matrix.c      ****         matrix_debouncing[i] = 0;
 117               		.loc 1 66 0 discriminator 3
 118 0030 1192      		st Z+,__zero_reg__
 119 0032 1192      		st Z+,__zero_reg__
  67:matrix.c      ****     }
 120               		.loc 1 67 0 discriminator 3
 121 0034 1D92      		st X+,__zero_reg__
 122 0036 1D92      		st X+,__zero_reg__
  65:matrix.c      ****         matrix[i] = 0;
 123               		.loc 1 65 0 discriminator 3
 124 0038 80E0      		ldi r24,hi8(matrix+12)
 125 003a E030      		cpi r30,lo8(matrix+12)
 126 003c F807      		cpc r31,r24
 127 003e 01F4      		brne .L5
 128               	/* epilogue start */
 129               	.LBE25:
  69:matrix.c      **** 
 130               		.loc 1 69 0
 131 0040 0895      		ret
 132               		.cfi_endproc
 133               	.LFE9:
 135               		.section	.text.matrix_scan,"ax",@progbits
 136               	.global	matrix_scan
 138               	matrix_scan:
 139               	.LFB10:
  72:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 140               		.loc 1 72 0
 141               		.cfi_startproc
 142 0000 AF92      		push r10
 143               	.LCFI0:
 144               		.cfi_def_cfa_offset 3
 145               		.cfi_offset 10, -2
 146 0002 BF92      		push r11
 147               	.LCFI1:
 148               		.cfi_def_cfa_offset 4
 149               		.cfi_offset 11, -3
 150 0004 CF92      		push r12
 151               	.LCFI2:
 152               		.cfi_def_cfa_offset 5
 153               		.cfi_offset 12, -4
 154 0006 DF92      		push r13
 155               	.LCFI3:
 156               		.cfi_def_cfa_offset 6
 157               		.cfi_offset 13, -5
 158 0008 EF92      		push r14
 159               	.LCFI4:
 160               		.cfi_def_cfa_offset 7
 161               		.cfi_offset 14, -6
 162 000a FF92      		push r15
 163               	.LCFI5:
 164               		.cfi_def_cfa_offset 8
 165               		.cfi_offset 15, -7
 166 000c 0F93      		push r16
 167               	.LCFI6:
 168               		.cfi_def_cfa_offset 9
 169               		.cfi_offset 16, -8
 170 000e 1F93      		push r17
 171               	.LCFI7:
 172               		.cfi_def_cfa_offset 10
 173               		.cfi_offset 17, -9
 174 0010 CF93      		push r28
 175               	.LCFI8:
 176               		.cfi_def_cfa_offset 11
 177               		.cfi_offset 28, -10
 178 0012 DF93      		push r29
 179               	.LCFI9:
 180               		.cfi_def_cfa_offset 12
 181               		.cfi_offset 29, -11
 182               	/* prologue: function */
 183               	/* frame size = 0 */
 184               	/* stack size = 10 */
 185               	.L__stack_usage = 10
 186               	.LVL3:
 187 0014 A0E0      		ldi r26,lo8(matrix_debouncing)
 188 0016 AA2E      		mov r10,r26
 189 0018 A0E0      		ldi r26,hi8(matrix_debouncing)
 190 001a BA2E      		mov r11,r26
  72:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 191               		.loc 1 72 0
 192 001c E501      		movw r28,r10
 193               	.LBB40:
  73:matrix.c      ****         select_row(i);
 194               		.loc 1 73 0
 195 001e 10E0      		ldi r17,0
 196               	.LBB41:
 197               	.LBB42:
 198               	.LBB43:
 154:matrix.c      ****          (PINB&(1<<5) ? 0 : (1<<1)) |
 199               		.loc 1 154 0
 200 0020 01E0      		ldi r16,lo8(1)
 201               	.LBE43:
 202               	.LBE42:
  80:matrix.c      ****             }
 203               		.loc 1 80 0
 204 0022 B0E0      		ldi r27,lo8(__c.1997)
 205 0024 CB2E      		mov r12,r27
 206 0026 B0E0      		ldi r27,hi8(__c.1997)
 207 0028 DB2E      		mov r13,r27
 208               	.LVL4:
 209               	.L37:
 210               	.LBB45:
 211               	.LBB46:
 180:matrix.c      **** }
 181:matrix.c      **** 
 182:matrix.c      **** static void select_row(uint8_t row)
 183:matrix.c      **** {
 184:matrix.c      ****     // Output low(DDR:1, PORT:0) to select
 185:matrix.c      ****     switch (row) {
 212               		.loc 1 185 0
 213 002a 1330      		cpi r17,lo8(3)
 214 002c 01F0      		breq .L10
 215 002e 00F4      		brsh .L11
 216 0030 1130      		cpi r17,lo8(1)
 217 0032 01F0      		breq .L12
 218 0034 1230      		cpi r17,lo8(2)
 219 0036 01F0      		breq .L13
 220 0038 00C0      		rjmp .L9
 221               	.L11:
 222 003a 1430      		cpi r17,lo8(4)
 223 003c 01F0      		breq .L14
 224 003e 1530      		cpi r17,lo8(5)
 225 0040 01F0      		breq .L15
 226               	.L9:
 186:matrix.c      ****         case 0:
 187:matrix.c      ****             DDRF  |= (1<<0);
 227               		.loc 1 187 0
 228 0042 809A      		sbi 0x10,0
 188:matrix.c      ****             PORTF &= ~(1<<0);
 229               		.loc 1 188 0
 230 0044 8898      		cbi 0x11,0
 231 0046 00C0      		rjmp .L16
 232               	.L12:
 189:matrix.c      ****             break;
 190:matrix.c      ****         case 1:
 191:matrix.c      ****             DDRF  |= (1<<1);
 233               		.loc 1 191 0
 234 0048 819A      		sbi 0x10,1
 192:matrix.c      ****             PORTF &= ~(1<<1);
 235               		.loc 1 192 0
 236 004a 8998      		cbi 0x11,1
 237 004c 00C0      		rjmp .L16
 238               	.L13:
 193:matrix.c      ****             break;
 194:matrix.c      ****         case 2:
 195:matrix.c      ****             DDRF  |= (1<<4);
 239               		.loc 1 195 0
 240 004e 849A      		sbi 0x10,4
 196:matrix.c      ****             PORTF &= ~(1<<4);
 241               		.loc 1 196 0
 242 0050 8C98      		cbi 0x11,4
 243 0052 00C0      		rjmp .L16
 244               	.L10:
 197:matrix.c      ****             break;
 198:matrix.c      ****         case 3:
 199:matrix.c      ****             DDRF  |= (1<<5);
 245               		.loc 1 199 0
 246 0054 859A      		sbi 0x10,5
 200:matrix.c      ****             PORTF &= ~(1<<5);
 247               		.loc 1 200 0
 248 0056 8D98      		cbi 0x11,5
 249 0058 00C0      		rjmp .L16
 250               	.L14:
 201:matrix.c      ****             break;
 202:matrix.c      ****         case 4:
 203:matrix.c      ****             DDRF  |= (1<<6);
 251               		.loc 1 203 0
 252 005a 869A      		sbi 0x10,6
 204:matrix.c      ****             PORTF &= ~(1<<6);
 253               		.loc 1 204 0
 254 005c 8E98      		cbi 0x11,6
 255 005e 00C0      		rjmp .L16
 256               	.L15:
 205:matrix.c      ****             break;
 206:matrix.c      ****         case 5:
 207:matrix.c      ****             DDRF  |= (1<<7);
 257               		.loc 1 207 0
 258 0060 879A      		sbi 0x10,7
 208:matrix.c      ****             PORTF &= ~(1<<7);
 259               		.loc 1 208 0
 260 0062 8F98      		cbi 0x11,7
 261               	.L16:
 262               	.LVL5:
 263               	.LBE46:
 264               	.LBE45:
 265               	.LBB47:
 266               	.LBB48:
 267               		.file 2 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/avr/include/util/delay.h **** 
 189:/usr/avr/include/util/delay.h **** #else
 190:/usr/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/avr/include/util/delay.h **** 	{
 196:/usr/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/avr/include/util/delay.h **** 		{
 200:/usr/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/avr/include/util/delay.h **** 		}
 204:/usr/avr/include/util/delay.h **** 		return;
 205:/usr/avr/include/util/delay.h **** 	}
 206:/usr/avr/include/util/delay.h **** 	else
 207:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/avr/include/util/delay.h **** #endif
 210:/usr/avr/include/util/delay.h **** }
 211:/usr/avr/include/util/delay.h **** 
 212:/usr/avr/include/util/delay.h **** /**
 213:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/avr/include/util/delay.h **** 
 215:/usr/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/avr/include/util/delay.h **** 
 217:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/avr/include/util/delay.h **** 
 220:/usr/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/avr/include/util/delay.h **** 
 222:/usr/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/avr/include/util/delay.h **** 
 226:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/avr/include/util/delay.h **** 
 231:/usr/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/avr/include/util/delay.h **** 
 236:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/avr/include/util/delay.h ****    respectively.
 240:/usr/avr/include/util/delay.h **** 
 241:/usr/avr/include/util/delay.h ****    \note
 242:/usr/avr/include/util/delay.h **** 
 243:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/avr/include/util/delay.h **** 
 253:/usr/avr/include/util/delay.h ****  */
 254:/usr/avr/include/util/delay.h **** void
 255:/usr/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/avr/include/util/delay.h **** {
 257:/usr/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/avr/include/util/delay.h **** 
 265:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/avr/include/util/delay.h **** 
 268:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/avr/include/util/delay.h **** 
 271:/usr/avr/include/util/delay.h **** 	#else
 272:/usr/avr/include/util/delay.h **** 		//round up by default
 273:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/avr/include/util/delay.h **** 	#endif
 275:/usr/avr/include/util/delay.h **** 
 276:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 268               		.loc 2 276 0
 269 0064 80EA      		ldi r24,lo8(-96)
 270 0066 8A95      	1:	dec r24
 271 0068 01F4      		brne 1b
 272               	.LVL6:
 273               	.LBE48:
 274               	.LBE47:
 275               	.LBB49:
 276               	.LBB44:
 154:matrix.c      ****          (PINB&(1<<5) ? 0 : (1<<1)) |
 277               		.loc 1 154 0
 278 006a 83B1      		in r24,0x3
 279 006c 8295      		swap r24
 280 006e 8695      		lsr r24
 281 0070 8695      		lsr r24
 282 0072 8370      		andi r24,lo8(3)
 283 0074 8027      		eor r24,r16
 284 0076 80FB      		bst r24,0
 285 0078 EE24      		clr r14
 286 007a E0F8      		bld r14,0
 287 007c F12C      		mov r15,__zero_reg__
 155:matrix.c      ****          (PINB&(1<<4) ? 0 : (1<<2)) |
 288               		.loc 1 155 0
 289 007e 1D99      		sbic 0x3,5
 290 0080 00C0      		rjmp .L43
 291 0082 82E0      		ldi r24,lo8(2)
 292 0084 90E0      		ldi r25,0
 293 0086 00C0      		rjmp .L17
 294               	.L43:
 295 0088 80E0      		ldi r24,0
 296 008a 90E0      		ldi r25,0
 297               	.L17:
 154:matrix.c      ****          (PINB&(1<<5) ? 0 : (1<<1)) |
 298               		.loc 1 154 0
 299 008c 9701      		movw r18,r14
 300 008e 282B      		or r18,r24
 301 0090 392B      		or r19,r25
 156:matrix.c      ****          (PIND&(1<<7) ? 0 : (1<<3)) |
 302               		.loc 1 156 0
 303 0092 1C99      		sbic 0x3,4
 304 0094 00C0      		rjmp .L44
 305 0096 84E0      		ldi r24,lo8(4)
 306 0098 90E0      		ldi r25,0
 307 009a 00C0      		rjmp .L18
 308               	.L44:
 309 009c 80E0      		ldi r24,0
 310 009e 90E0      		ldi r25,0
 311               	.L18:
 155:matrix.c      ****          (PINB&(1<<4) ? 0 : (1<<2)) |
 312               		.loc 1 155 0
 313 00a0 822B      		or r24,r18
 314 00a2 932B      		or r25,r19
 157:matrix.c      ****          (PIND&(1<<6) ? 0 : (1<<4)) |
 315               		.loc 1 157 0
 316 00a4 49B1      		in r20,0x9
 317 00a6 042E      		mov __tmp_reg__,r20
 318 00a8 000C      		lsl r0
 319 00aa 550B      		sbc r21,r21
 320 00ac 4095      		com r20
 321 00ae 5095      		com r21
 322 00b0 9A01      		movw r18,r20
 323 00b2 2227      		clr r18
 324 00b4 330F      		lsl r19
 325 00b6 221F      		rol r18
 326 00b8 3327      		clr r19
 327 00ba F3E0      		ldi r31,3
 328               		1:
 329 00bc 220F      		lsl r18
 330 00be 331F      		rol r19
 331 00c0 FA95      		dec r31
 332 00c2 01F4      		brne 1b
 156:matrix.c      ****          (PIND&(1<<7) ? 0 : (1<<3)) |
 333               		.loc 1 156 0
 334 00c4 282B      		or r18,r24
 335 00c6 392B      		or r19,r25
 158:matrix.c      ****          (PINC&(1<<7) ? 0 : (1<<5)) |
 336               		.loc 1 158 0
 337 00c8 4E99      		sbic 0x9,6
 338 00ca 00C0      		rjmp .L46
 339 00cc 80E1      		ldi r24,lo8(16)
 340 00ce 90E0      		ldi r25,0
 341 00d0 00C0      		rjmp .L20
 342               	.L46:
 343 00d2 80E0      		ldi r24,0
 344 00d4 90E0      		ldi r25,0
 345               	.L20:
 157:matrix.c      ****          (PIND&(1<<6) ? 0 : (1<<4)) |
 346               		.loc 1 157 0
 347 00d6 A901      		movw r20,r18
 348 00d8 482B      		or r20,r24
 349 00da 592B      		or r21,r25
 159:matrix.c      ****          (PINC&(1<<6) ? 0 : (1<<6)) |
 350               		.loc 1 159 0
 351 00dc 26B1      		in r18,0x6
 352 00de 022E      		mov __tmp_reg__,r18
 353 00e0 000C      		lsl r0
 354 00e2 330B      		sbc r19,r19
 355 00e4 2095      		com r18
 356 00e6 3095      		com r19
 357 00e8 C901      		movw r24,r18
 358 00ea 8827      		clr r24
 359 00ec 990F      		lsl r25
 360 00ee 881F      		rol r24
 361 00f0 9927      		clr r25
 362 00f2 75E0      		ldi r23,5
 363               		1:
 364 00f4 880F      		lsl r24
 365 00f6 991F      		rol r25
 366 00f8 7A95      		dec r23
 367 00fa 01F4      		brne 1b
 158:matrix.c      ****          (PINC&(1<<7) ? 0 : (1<<5)) |
 368               		.loc 1 158 0
 369 00fc 842B      		or r24,r20
 370 00fe 952B      		or r25,r21
 160:matrix.c      ****          (PIND&(1<<3) ? 0 : (1<<7)) |
 371               		.loc 1 160 0
 372 0100 3699      		sbic 0x6,6
 373 0102 00C0      		rjmp .L48
 374 0104 20E4      		ldi r18,lo8(64)
 375 0106 30E0      		ldi r19,0
 376 0108 00C0      		rjmp .L22
 377               	.L48:
 378 010a 20E0      		ldi r18,0
 379 010c 30E0      		ldi r19,0
 380               	.L22:
 159:matrix.c      ****          (PINC&(1<<6) ? 0 : (1<<6)) |
 381               		.loc 1 159 0
 382 010e 822B      		or r24,r18
 383 0110 932B      		or r25,r19
 161:matrix.c      ****          (PIND&(1<<2) ? 0 : (1<<8)) |
 384               		.loc 1 161 0
 385 0112 4B99      		sbic 0x9,3
 386 0114 00C0      		rjmp .L49
 387 0116 20E8      		ldi r18,lo8(-128)
 388 0118 30E0      		ldi r19,0
 389 011a 00C0      		rjmp .L23
 390               	.L49:
 391 011c 20E0      		ldi r18,0
 392 011e 30E0      		ldi r19,0
 393               	.L23:
 160:matrix.c      ****          (PIND&(1<<3) ? 0 : (1<<7)) |
 394               		.loc 1 160 0
 395 0120 822B      		or r24,r18
 396 0122 932B      		or r25,r19
 162:matrix.c      ****          (PIND&(1<<1) ? 0 : (1<<9)) |
 397               		.loc 1 162 0
 398 0124 4A99      		sbic 0x9,2
 399 0126 00C0      		rjmp .L50
 400 0128 E0E0      		ldi r30,0
 401 012a F1E0      		ldi r31,lo8(1)
 402 012c 00C0      		rjmp .L24
 403               	.L50:
 404 012e E0E0      		ldi r30,0
 405 0130 F0E0      		ldi r31,0
 406               	.L24:
 161:matrix.c      ****          (PIND&(1<<2) ? 0 : (1<<8)) |
 407               		.loc 1 161 0
 408 0132 8E2B      		or r24,r30
 409 0134 9F2B      		or r25,r31
 163:matrix.c      ****          (PIND&(1<<0) ? 0 : (1<<10)) |
 410               		.loc 1 163 0
 411 0136 4999      		sbic 0x9,1
 412 0138 00C0      		rjmp .L51
 413 013a 60E0      		ldi r22,0
 414 013c 72E0      		ldi r23,lo8(2)
 415 013e 00C0      		rjmp .L25
 416               	.L51:
 417 0140 60E0      		ldi r22,0
 418 0142 70E0      		ldi r23,0
 419               	.L25:
 162:matrix.c      ****          (PIND&(1<<1) ? 0 : (1<<9)) |
 420               		.loc 1 162 0
 421 0144 862B      		or r24,r22
 422 0146 972B      		or r25,r23
 164:matrix.c      ****          (PINB&(1<<7) ? 0 : (1<<11)) |
 423               		.loc 1 164 0
 424 0148 4899      		sbic 0x9,0
 425 014a 00C0      		rjmp .L52
 426 014c 20E0      		ldi r18,0
 427 014e 34E0      		ldi r19,lo8(4)
 428 0150 00C0      		rjmp .L26
 429               	.L52:
 430 0152 20E0      		ldi r18,0
 431 0154 30E0      		ldi r19,0
 432               	.L26:
 163:matrix.c      ****          (PIND&(1<<0) ? 0 : (1<<10)) |
 433               		.loc 1 163 0
 434 0156 AC01      		movw r20,r24
 435 0158 422B      		or r20,r18
 436 015a 532B      		or r21,r19
 165:matrix.c      ****          (PINB&(1<<3) ? 0 : (1<<12)) |
 437               		.loc 1 165 0
 438 015c 23B1      		in r18,0x3
 439 015e 022E      		mov __tmp_reg__,r18
 440 0160 000C      		lsl r0
 441 0162 330B      		sbc r19,r19
 442 0164 2095      		com r18
 443 0166 3095      		com r19
 444 0168 C901      		movw r24,r18
 445 016a 8827      		clr r24
 446 016c 990F      		lsl r25
 447 016e 881F      		rol r24
 448 0170 9927      		clr r25
 449 0172 982F      		mov r25,r24
 450 0174 8827      		clr r24
 451 0176 990F      		lsl r25
 452 0178 990F      		lsl r25
 453 017a 990F      		lsl r25
 164:matrix.c      ****          (PINB&(1<<7) ? 0 : (1<<11)) |
 454               		.loc 1 164 0
 455 017c 842B      		or r24,r20
 456 017e 952B      		or r25,r21
 166:matrix.c      ****          (PINB&(1<<2) ? 0 : (1<<13)) |
 457               		.loc 1 166 0
 458 0180 1B99      		sbic 0x3,3
 459 0182 00C0      		rjmp .L54
 460 0184 20E0      		ldi r18,0
 461 0186 30E1      		ldi r19,lo8(16)
 462 0188 00C0      		rjmp .L28
 463               	.L54:
 464 018a 20E0      		ldi r18,0
 465 018c 30E0      		ldi r19,0
 466               	.L28:
 165:matrix.c      ****          (PINB&(1<<3) ? 0 : (1<<12)) |
 467               		.loc 1 165 0
 468 018e 822B      		or r24,r18
 469 0190 932B      		or r25,r19
 167:matrix.c      ****          (PINB&(1<<1) ? 0 : (1<<14));
 470               		.loc 1 167 0
 471 0192 1A99      		sbic 0x3,2
 472 0194 00C0      		rjmp .L55
 473 0196 20E0      		ldi r18,0
 474 0198 30E2      		ldi r19,lo8(32)
 475 019a 00C0      		rjmp .L29
 476               	.L55:
 477 019c 20E0      		ldi r18,0
 478 019e 30E0      		ldi r19,0
 479               	.L29:
 166:matrix.c      ****          (PINB&(1<<2) ? 0 : (1<<13)) |
 480               		.loc 1 166 0
 481 01a0 822B      		or r24,r18
 482 01a2 932B      		or r25,r19
 168:matrix.c      **** }
 483               		.loc 1 168 0
 484 01a4 1999      		sbic 0x3,1
 485 01a6 00C0      		rjmp .L56
 486 01a8 20E0      		ldi r18,0
 487 01aa 30E4      		ldi r19,lo8(64)
 488 01ac 00C0      		rjmp .L30
 489               	.L56:
 490 01ae 20E0      		ldi r18,0
 491 01b0 30E0      		ldi r19,0
 492               	.L30:
 154:matrix.c      ****          (PINB&(1<<5) ? 0 : (1<<1)) |
 493               		.loc 1 154 0
 494 01b2 822B      		or r24,r18
 495 01b4 932B      		or r25,r19
 496               	.LBE44:
 497               	.LBE49:
  77:matrix.c      ****             matrix_debouncing[i] = cols;
 498               		.loc 1 77 0
 499 01b6 2881      		ld r18,Y
 500 01b8 3981      		ldd r19,Y+1
 501 01ba 2817      		cp r18,r24
 502 01bc 3907      		cpc r19,r25
 503 01be 01F0      		breq .L31
  78:matrix.c      ****             if (debouncing) {
 504               		.loc 1 78 0
 505 01c0 9983      		std Y+1,r25
 506 01c2 8883      		st Y,r24
  79:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 507               		.loc 1 79 0
 508 01c4 8091 0000 		lds r24,debouncing
 509 01c8 8823      		tst r24
 510 01ca 01F0      		breq .L33
  80:matrix.c      ****             }
 511               		.loc 1 80 0
 512 01cc 8091 0000 		lds r24,debug_config
 513 01d0 80FF      		sbrs r24,0
 514 01d2 00C0      		rjmp .L34
  80:matrix.c      ****             }
 515               		.loc 1 80 0 is_stmt 0 discriminator 1
 516 01d4 80E0      		ldi r24,lo8(__c.1995)
 517 01d6 90E0      		ldi r25,hi8(__c.1995)
 518 01d8 0E94 0000 		call xputs
 519               	.LVL7:
 520               	.L34:
  80:matrix.c      ****             }
 521               		.loc 1 80 0 discriminator 3
 522 01dc 8091 0000 		lds r24,debug_config
 523 01e0 80FF      		sbrs r24,0
 524 01e2 00C0      		rjmp .L35
  80:matrix.c      ****             }
 525               		.loc 1 80 0 discriminator 4
 526 01e4 8091 0000 		lds r24,debouncing
 527 01e8 1F92      		push __zero_reg__
 528               	.LCFI10:
 529               		.cfi_def_cfa_offset 13
 530 01ea 8F93      		push r24
 531               	.LCFI11:
 532               		.cfi_def_cfa_offset 14
 533 01ec DF92      		push r13
 534               	.LCFI12:
 535               		.cfi_def_cfa_offset 15
 536 01ee CF92      		push r12
 537               	.LCFI13:
 538               		.cfi_def_cfa_offset 16
 539 01f0 0E94 0000 		call __xprintf
 540               	.LVL8:
 541 01f4 0F90      		pop __tmp_reg__
 542 01f6 0F90      		pop __tmp_reg__
 543 01f8 0F90      		pop __tmp_reg__
 544 01fa 0F90      		pop __tmp_reg__
 545               	.LCFI14:
 546               		.cfi_def_cfa_offset 12
 547               	.L35:
  80:matrix.c      ****             }
 548               		.loc 1 80 0 discriminator 6
 549 01fc 8091 0000 		lds r24,debug_config
 550 0200 80FF      		sbrs r24,0
 551 0202 00C0      		rjmp .L33
  80:matrix.c      ****             }
 552               		.loc 1 80 0 discriminator 7
 553 0204 80E0      		ldi r24,lo8(__c.1999)
 554 0206 90E0      		ldi r25,hi8(__c.1999)
 555 0208 0E94 0000 		call xputs
 556               	.LVL9:
 557               	.L33:
  82:matrix.c      ****         }
 558               		.loc 1 82 0 is_stmt 1
 559 020c 85E0      		ldi r24,lo8(5)
 560 020e 8093 0000 		sts debouncing,r24
 561               	.L31:
  84:matrix.c      ****     }
 562               		.loc 1 84 0 discriminator 2
 563 0212 0E94 0000 		call unselect_rows
 564               	.LVL10:
 565               	.LBE41:
  73:matrix.c      ****         select_row(i);
 566               		.loc 1 73 0 discriminator 2
 567 0216 1F5F      		subi r17,lo8(-(1))
 568               	.LVL11:
 569 0218 2296      		adiw r28,2
 570 021a 1630      		cpi r17,lo8(6)
 571 021c 01F0      		breq .+2
 572 021e 00C0      		rjmp .L37
 573               	.LBE40:
  87:matrix.c      ****         if (--debouncing) {
 574               		.loc 1 87 0
 575 0220 8091 0000 		lds r24,debouncing
 576 0224 8823      		tst r24
 577 0226 01F0      		breq .L39
  88:matrix.c      ****             _delay_ms(1);
 578               		.loc 1 88 0
 579 0228 8150      		subi r24,lo8(-(-1))
 580 022a 8093 0000 		sts debouncing,r24
 581 022e 8823      		tst r24
 582 0230 01F0      		breq .L40
 583               	.LVL12:
 584               	.LBB50:
 585               	.LBB51:
 187:/usr/avr/include/util/delay.h **** 
 586               		.loc 2 187 0
 587 0232 AFE9      		ldi r26,lo8(3999)
 588 0234 BFE0      		ldi r27,hi8(3999)
 589 0236 1197      	1:	sbiw r26,1
 590 0238 01F4      		brne 1b
 591 023a 00C0      		rjmp .
 592 023c 0000      		nop
 593 023e 00C0      		rjmp .L39
 594               	.LVL13:
 595               	.L40:
 596 0240 E0E0      		ldi r30,lo8(matrix)
 597 0242 F0E0      		ldi r31,hi8(matrix)
 598               	.L41:
 599               	.LBE51:
 600               	.LBE50:
 601               	.LBB52:
  92:matrix.c      ****             }
 602               		.loc 1 92 0 discriminator 3
 603 0244 D501      		movw r26,r10
 604 0246 8D91      		ld r24,X+
 605 0248 9D91      		ld r25,X+
 606 024a 5D01      		movw r10,r26
 607 024c 8193      		st Z+,r24
 608 024e 9193      		st Z+,r25
 609               	.LVL14:
  91:matrix.c      ****                 matrix[i] = matrix_debouncing[i];
 610               		.loc 1 91 0 discriminator 3
 611 0250 B0E0      		ldi r27,lo8(matrix_debouncing+12)
 612 0252 AB16      		cp r10,r27
 613 0254 B0E0      		ldi r27,hi8(matrix_debouncing+12)
 614 0256 BB06      		cpc r11,r27
 615 0258 01F4      		brne .L41
 616               	.L39:
 617               	.LBE52:
  98:matrix.c      **** 
 618               		.loc 1 98 0
 619 025a 81E0      		ldi r24,lo8(1)
 620               	/* epilogue start */
 621 025c DF91      		pop r29
 622 025e CF91      		pop r28
 623 0260 1F91      		pop r17
 624               	.LVL15:
 625 0262 0F91      		pop r16
 626 0264 FF90      		pop r15
 627 0266 EF90      		pop r14
 628 0268 DF90      		pop r13
 629 026a CF90      		pop r12
 630 026c BF90      		pop r11
 631 026e AF90      		pop r10
 632 0270 0895      		ret
 633               		.cfi_endproc
 634               	.LFE10:
 636               		.section	.text.matrix_is_modified,"ax",@progbits
 637               	.global	matrix_is_modified
 639               	matrix_is_modified:
 640               	.LFB11:
 101:matrix.c      ****     if (debouncing) return false;
 641               		.loc 1 101 0
 642               		.cfi_startproc
 643               	/* prologue: function */
 644               	/* frame size = 0 */
 645               	/* stack size = 0 */
 646               	.L__stack_usage = 0
 647 0000 81E0      		ldi r24,lo8(1)
 648 0002 9091 0000 		lds r25,debouncing
 649 0006 9111      		cpse r25,__zero_reg__
 650 0008 80E0      		ldi r24,0
 651               	.L69:
 104:matrix.c      **** 
 652               		.loc 1 104 0
 653 000a 0895      		ret
 654               		.cfi_endproc
 655               	.LFE11:
 657               		.section	.text.matrix_is_on,"ax",@progbits
 658               	.global	matrix_is_on
 660               	matrix_is_on:
 661               	.LFB12:
 108:matrix.c      ****     return (matrix[row] & ((matrix_row_t)1<<col));
 662               		.loc 1 108 0
 663               		.cfi_startproc
 664               	.LVL16:
 665               	/* prologue: function */
 666               	/* frame size = 0 */
 667               	/* stack size = 0 */
 668               	.L__stack_usage = 0
 109:matrix.c      **** }
 669               		.loc 1 109 0
 670 0000 E82F      		mov r30,r24
 671 0002 F0E0      		ldi r31,0
 672 0004 EE0F      		lsl r30
 673 0006 FF1F      		rol r31
 674               	.LVL17:
 675 0008 E050      		subi r30,lo8(-(matrix))
 676 000a F040      		sbci r31,hi8(-(matrix))
 677 000c 21E0      		ldi r18,lo8(1)
 678 000e 30E0      		ldi r19,0
 679 0010 00C0      		rjmp 2f
 680               		1:
 681 0012 220F      		lsl r18
 682 0014 331F      		rol r19
 683               		2:
 684 0016 6A95      		dec r22
 685 0018 02F4      		brpl 1b
 686 001a 8081      		ld r24,Z
 687 001c 9181      		ldd r25,Z+1
 688 001e 2823      		and r18,r24
 689 0020 3923      		and r19,r25
 690 0022 81E0      		ldi r24,lo8(1)
 691 0024 232B      		or r18,r19
 692 0026 01F4      		brne .L74
 693 0028 80E0      		ldi r24,0
 694               	.L74:
 110:matrix.c      **** 
 695               		.loc 1 110 0
 696 002a 0895      		ret
 697               		.cfi_endproc
 698               	.LFE12:
 700               		.section	.text.matrix_get_row,"ax",@progbits
 701               	.global	matrix_get_row
 703               	matrix_get_row:
 704               	.LFB13:
 114:matrix.c      ****     return matrix[row];
 705               		.loc 1 114 0
 706               		.cfi_startproc
 707               	.LVL18:
 708               	/* prologue: function */
 709               	/* frame size = 0 */
 710               	/* stack size = 0 */
 711               	.L__stack_usage = 0
 115:matrix.c      **** }
 712               		.loc 1 115 0
 713 0000 E82F      		mov r30,r24
 714 0002 F0E0      		ldi r31,0
 715 0004 EE0F      		lsl r30
 716 0006 FF1F      		rol r31
 717               	.LVL19:
 718 0008 E050      		subi r30,lo8(-(matrix))
 719 000a F040      		sbci r31,hi8(-(matrix))
 116:matrix.c      **** 
 720               		.loc 1 116 0
 721 000c 8081      		ld r24,Z
 722 000e 9181      		ldd r25,Z+1
 723 0010 0895      		ret
 724               		.cfi_endproc
 725               	.LFE13:
 727               		.section	.text.matrix_print,"ax",@progbits
 728               	.global	matrix_print
 730               	matrix_print:
 731               	.LFB14:
 119:matrix.c      ****     print("\nr/c 0123456789ABCDEF\n");
 732               		.loc 1 119 0
 733               		.cfi_startproc
 734 0000 CF92      		push r12
 735               	.LCFI15:
 736               		.cfi_def_cfa_offset 3
 737               		.cfi_offset 12, -2
 738 0002 DF92      		push r13
 739               	.LCFI16:
 740               		.cfi_def_cfa_offset 4
 741               		.cfi_offset 13, -3
 742 0004 EF92      		push r14
 743               	.LCFI17:
 744               		.cfi_def_cfa_offset 5
 745               		.cfi_offset 14, -4
 746 0006 FF92      		push r15
 747               	.LCFI18:
 748               		.cfi_def_cfa_offset 6
 749               		.cfi_offset 15, -5
 750 0008 0F93      		push r16
 751               	.LCFI19:
 752               		.cfi_def_cfa_offset 7
 753               		.cfi_offset 16, -6
 754 000a 1F93      		push r17
 755               	.LCFI20:
 756               		.cfi_def_cfa_offset 8
 757               		.cfi_offset 17, -7
 758 000c CF93      		push r28
 759               	.LCFI21:
 760               		.cfi_def_cfa_offset 9
 761               		.cfi_offset 28, -8
 762 000e DF93      		push r29
 763               	.LCFI22:
 764               		.cfi_def_cfa_offset 10
 765               		.cfi_offset 29, -9
 766               	/* prologue: function */
 767               	/* frame size = 0 */
 768               	/* stack size = 8 */
 769               	.L__stack_usage = 8
 120:matrix.c      ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 770               		.loc 1 120 0
 771 0010 80E0      		ldi r24,lo8(__c.2021)
 772 0012 90E0      		ldi r25,hi8(__c.2021)
 773 0014 0E94 0000 		call xputs
 774 0018 80E0      		ldi r24,lo8(matrix)
 775 001a E82E      		mov r14,r24
 776 001c 80E0      		ldi r24,hi8(matrix)
 777 001e F82E      		mov r15,r24
 778 0020 C0E0      		ldi r28,0
 779 0022 D0E0      		ldi r29,0
 780               	.LBB53:
 122:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 781               		.loc 1 122 0
 782 0024 90E0      		ldi r25,lo8(__c.2024)
 783 0026 C92E      		mov r12,r25
 784 0028 90E0      		ldi r25,hi8(__c.2024)
 785 002a D92E      		mov r13,r25
 123:matrix.c      ****         print("\n");
 786               		.loc 1 123 0
 787 002c 00E0      		ldi r16,lo8(__c.2028)
 788 002e 10E0      		ldi r17,hi8(__c.2028)
 789               	.L77:
 122:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 790               		.loc 1 122 0 discriminator 3
 791 0030 DF93      		push r29
 792               	.LCFI23:
 793               		.cfi_def_cfa_offset 11
 794 0032 CF93      		push r28
 795               	.LCFI24:
 796               		.cfi_def_cfa_offset 12
 797 0034 DF92      		push r13
 798               	.LCFI25:
 799               		.cfi_def_cfa_offset 13
 800 0036 CF92      		push r12
 801               	.LCFI26:
 802               		.cfi_def_cfa_offset 14
 803 0038 0E94 0000 		call __xprintf
 804 003c 80E0      		ldi r24,lo8(__c.2026)
 805 003e 90E0      		ldi r25,hi8(__c.2026)
 806 0040 0E94 0000 		call xputs
 123:matrix.c      ****         print("\n");
 807               		.loc 1 123 0 discriminator 3
 808 0044 F701      		movw r30,r14
 809 0046 8191      		ld r24,Z+
 810 0048 9191      		ld r25,Z+
 811 004a 7F01      		movw r14,r30
 812 004c 0E94 0000 		call bitrev16
 813 0050 9F93      		push r25
 814               	.LCFI27:
 815               		.cfi_def_cfa_offset 15
 816 0052 8F93      		push r24
 817               	.LCFI28:
 818               		.cfi_def_cfa_offset 16
 819 0054 1F93      		push r17
 820               	.LCFI29:
 821               		.cfi_def_cfa_offset 17
 822 0056 0F93      		push r16
 823               	.LCFI30:
 824               		.cfi_def_cfa_offset 18
 825 0058 0E94 0000 		call __xprintf
 124:matrix.c      ****     }
 826               		.loc 1 124 0 discriminator 3
 827 005c 80E0      		ldi r24,lo8(__c.2030)
 828 005e 90E0      		ldi r25,hi8(__c.2030)
 829 0060 0E94 0000 		call xputs
 830 0064 2196      		adiw r28,1
 121:matrix.c      ****         phex(row); print(": ");
 831               		.loc 1 121 0 discriminator 3
 832 0066 8DB7      		in r24,__SP_L__
 833 0068 9EB7      		in r25,__SP_H__
 834 006a 0896      		adiw r24,8
 835 006c 0FB6      		in __tmp_reg__,__SREG__
 836 006e F894      		cli
 837 0070 9EBF      		out __SP_H__,r25
 838 0072 0FBE      		out __SREG__,__tmp_reg__
 839 0074 8DBF      		out __SP_L__,r24
 840               	.LCFI31:
 841               		.cfi_def_cfa_offset 10
 842 0076 C630      		cpi r28,6
 843 0078 D105      		cpc r29,__zero_reg__
 844 007a 01F4      		brne .L77
 845               	/* epilogue start */
 846               	.LBE53:
 126:matrix.c      **** 
 847               		.loc 1 126 0
 848 007c DF91      		pop r29
 849 007e CF91      		pop r28
 850 0080 1F91      		pop r17
 851 0082 0F91      		pop r16
 852 0084 FF90      		pop r15
 853 0086 EF90      		pop r14
 854 0088 DF90      		pop r13
 855 008a CF90      		pop r12
 856 008c 0895      		ret
 857               		.cfi_endproc
 858               	.LFE14:
 860               		.section	.text.matrix_key_count,"ax",@progbits
 861               	.global	matrix_key_count
 863               	matrix_key_count:
 864               	.LFB15:
 129:matrix.c      ****     uint8_t count = 0;
 865               		.loc 1 129 0
 866               		.cfi_startproc
 867 0000 0F93      		push r16
 868               	.LCFI32:
 869               		.cfi_def_cfa_offset 3
 870               		.cfi_offset 16, -2
 871 0002 1F93      		push r17
 872               	.LCFI33:
 873               		.cfi_def_cfa_offset 4
 874               		.cfi_offset 17, -3
 875 0004 CF93      		push r28
 876               	.LCFI34:
 877               		.cfi_def_cfa_offset 5
 878               		.cfi_offset 28, -4
 879               	/* prologue: function */
 880               	/* frame size = 0 */
 881               	/* stack size = 3 */
 882               	.L__stack_usage = 3
 883               	.LVL20:
 884 0006 00E0      		ldi r16,lo8(matrix)
 885 0008 10E0      		ldi r17,hi8(matrix)
 130:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 886               		.loc 1 130 0
 887 000a C0E0      		ldi r28,0
 888               	.LVL21:
 889               	.L80:
 890               	.LBB54:
 132:matrix.c      ****     }
 891               		.loc 1 132 0 discriminator 3
 892 000c F801      		movw r30,r16
 893 000e 8191      		ld r24,Z+
 894 0010 9191      		ld r25,Z+
 895 0012 8F01      		movw r16,r30
 896 0014 0E94 0000 		call bitpop16
 897               	.LVL22:
 898 0018 C80F      		add r28,r24
 899               	.LVL23:
 131:matrix.c      ****         count += bitpop16(matrix[i]);
 900               		.loc 1 131 0 discriminator 3
 901 001a F0E0      		ldi r31,hi8(matrix+12)
 902 001c 0030      		cpi r16,lo8(matrix+12)
 903 001e 1F07      		cpc r17,r31
 904 0020 01F4      		brne .L80
 905               	.LBE54:
 135:matrix.c      **** 
 906               		.loc 1 135 0
 907 0022 8C2F      		mov r24,r28
 908               	/* epilogue start */
 909 0024 CF91      		pop r28
 910               	.LVL24:
 911 0026 1F91      		pop r17
 912 0028 0F91      		pop r16
 913 002a 0895      		ret
 914               		.cfi_endproc
 915               	.LFE15:
 917               		.section	.progmem.data.__c.2030,"a",@progbits
 920               	__c.2030:
 921 0000 0A00      		.string	"\n"
 922               		.section	.progmem.data.__c.2028,"a",@progbits
 925               	__c.2028:
 926 0000 2530 3136 		.string	"%016b"
 926      6200 
 927               		.section	.progmem.data.__c.2026,"a",@progbits
 930               	__c.2026:
 931 0000 3A20 00   		.string	": "
 932               		.section	.progmem.data.__c.2024,"a",@progbits
 935               	__c.2024:
 936 0000 2530 3258 		.string	"%02X"
 936      00
 937               		.section	.progmem.data.__c.2021,"a",@progbits
 940               	__c.2021:
 941 0000 0A72 2F63 		.string	"\nr/c 0123456789ABCDEF\n"
 941      2030 3132 
 941      3334 3536 
 941      3738 3941 
 941      4243 4445 
 942               		.section	.progmem.data.__c.1999,"a",@progbits
 945               	__c.1999:
 946 0000 0A00      		.string	"\n"
 947               		.section	.progmem.data.__c.1997,"a",@progbits
 950               	__c.1997:
 951 0000 2530 3258 		.string	"%02X"
 951      00
 952               		.section	.progmem.data.__c.1995,"a",@progbits
 955               	__c.1995:
 956 0000 626F 756E 		.string	"bounce!: "
 956      6365 213A 
 956      2000 
 957               		.section	.bss.matrix_debouncing,"aw",@nobits
 960               	matrix_debouncing:
 961 0000 0000 0000 		.zero	12
 961      0000 0000 
 961      0000 0000 
 962               		.section	.bss.matrix,"aw",@nobits
 965               	matrix:
 966 0000 0000 0000 		.zero	12
 966      0000 0000 
 966      0000 0000 
 967               		.section	.data.debouncing,"aw",@progbits
 970               	debouncing:
 971 0000 05        		.byte	5
 972               		.text
 973               	.Letext0:
 974               		.file 3 "/usr/avr/include/stdint.h"
 975               		.file 4 "../../tmk_core/common/debug.h"
 976               		.file 5 "../../tmk_core/common/matrix.h"
 977               		.file 6 "../../tmk_core/common/avr/xprintf.h"
 978               		.file 7 "../../tmk_core/common/util.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
     /tmp/cck5axXZ.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cck5axXZ.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cck5axXZ.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cck5axXZ.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cck5axXZ.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cck5axXZ.s:12     .text.unselect_rows:0000000000000000 unselect_rows
     /tmp/cck5axXZ.s:36     .text.matrix_rows:0000000000000000 matrix_rows
     /tmp/cck5axXZ.s:53     .text.matrix_cols:0000000000000000 matrix_cols
     /tmp/cck5axXZ.s:70     .text.matrix_init:0000000000000000 matrix_init
     /tmp/cck5axXZ.s:965    .bss.matrix:0000000000000000 matrix
     /tmp/cck5axXZ.s:960    .bss.matrix_debouncing:0000000000000000 matrix_debouncing
     /tmp/cck5axXZ.s:138    .text.matrix_scan:0000000000000000 matrix_scan
     /tmp/cck5axXZ.s:950    .progmem.data.__c.1997:0000000000000000 __c.1997
     /tmp/cck5axXZ.s:970    .data.debouncing:0000000000000000 debouncing
     /tmp/cck5axXZ.s:955    .progmem.data.__c.1995:0000000000000000 __c.1995
     /tmp/cck5axXZ.s:945    .progmem.data.__c.1999:0000000000000000 __c.1999
     /tmp/cck5axXZ.s:639    .text.matrix_is_modified:0000000000000000 matrix_is_modified
     /tmp/cck5axXZ.s:660    .text.matrix_is_on:0000000000000000 matrix_is_on
     /tmp/cck5axXZ.s:703    .text.matrix_get_row:0000000000000000 matrix_get_row
     /tmp/cck5axXZ.s:730    .text.matrix_print:0000000000000000 matrix_print
     /tmp/cck5axXZ.s:940    .progmem.data.__c.2021:0000000000000000 __c.2021
     /tmp/cck5axXZ.s:935    .progmem.data.__c.2024:0000000000000000 __c.2024
     /tmp/cck5axXZ.s:925    .progmem.data.__c.2028:0000000000000000 __c.2028
     /tmp/cck5axXZ.s:930    .progmem.data.__c.2026:0000000000000000 __c.2026
     /tmp/cck5axXZ.s:920    .progmem.data.__c.2030:0000000000000000 __c.2030
     /tmp/cck5axXZ.s:863    .text.matrix_key_count:0000000000000000 matrix_key_count

UNDEFINED SYMBOLS
debug_config
xputs
__xprintf
bitrev16
bitpop16
__do_copy_data
__do_clear_bss
